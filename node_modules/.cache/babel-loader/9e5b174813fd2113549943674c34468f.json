{"ast":null,"code":"module.exports = magnetURIDecode;\nmodule.exports.decode = magnetURIDecode;\nmodule.exports.encode = magnetURIEncode;\n\nconst base32 = require('thirty-two');\n\nconst uniq = require('uniq');\n/**\n * Parse a magnet URI and return an object of keys/values\n *\n * @param  {string} uri\n * @return {Object} parsed uri\n */\n\n\nfunction magnetURIDecode(uri) {\n  const result = {}; // Support 'magnet:' and 'stream-magnet:' uris\n\n  const data = uri.split('magnet:?')[1];\n  const params = data && data.length >= 0 ? data.split('&') : [];\n  params.forEach(param => {\n    const keyval = param.split('='); // This keyval is invalid, skip it\n\n    if (keyval.length !== 2) return;\n    const key = keyval[0];\n    let val = keyval[1]; // Clean up torrent name\n\n    if (key === 'dn') val = decodeURIComponent(val).replace(/\\+/g, ' '); // Address tracker (tr), exact source (xs), and acceptable source (as) are encoded\n    // URIs, so decode them\n\n    if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {\n      val = decodeURIComponent(val);\n    } // Return keywords as an array\n\n\n    if (key === 'kt') val = decodeURIComponent(val).split('+'); // Cast file index (ix) to a number\n\n    if (key === 'ix') val = Number(val); // If there are repeated parameters, return an array of values\n\n    if (result[key]) {\n      if (Array.isArray(result[key])) {\n        result[key].push(val);\n      } else {\n        const old = result[key];\n        result[key] = [old, val];\n      }\n    } else {\n      result[key] = val;\n    }\n  }); // Convenience properties for parity with `parse-torrent-file` module\n\n  let m;\n\n  if (result.xt) {\n    const xts = Array.isArray(result.xt) ? result.xt : [result.xt];\n    xts.forEach(xt => {\n      if (m = xt.match(/^urn:btih:(.{40})/)) {\n        result.infoHash = m[1].toLowerCase();\n      } else if (m = xt.match(/^urn:btih:(.{32})/)) {\n        const decodedStr = base32.decode(m[1]);\n        result.infoHash = Buffer.from(decodedStr, 'binary').toString('hex');\n      }\n    });\n  }\n\n  if (result.infoHash) result.infoHashBuffer = Buffer.from(result.infoHash, 'hex');\n  if (result.dn) result.name = result.dn;\n  if (result.kt) result.keywords = result.kt;\n  if (typeof result.tr === 'string') result.announce = [result.tr];else if (Array.isArray(result.tr)) result.announce = result.tr;else result.announce = [];\n  result.urlList = [];\n\n  if (typeof result.as === 'string' || Array.isArray(result.as)) {\n    result.urlList = result.urlList.concat(result.as);\n  }\n\n  if (typeof result.ws === 'string' || Array.isArray(result.ws)) {\n    result.urlList = result.urlList.concat(result.ws);\n  }\n\n  uniq(result.announce);\n  uniq(result.urlList);\n  return result;\n}\n\nfunction magnetURIEncode(obj) {\n  obj = Object.assign({}, obj); // clone obj, so we can mutate it\n  // support using convenience names, in addition to spec names\n  // (example: `infoHash` for `xt`, `name` for `dn`)\n\n  if (obj.infoHashBuffer) obj.xt = `urn:btih:${obj.infoHashBuffer.toString('hex')}`;\n  if (obj.infoHash) obj.xt = `urn:btih:${obj.infoHash}`;\n  if (obj.name) obj.dn = obj.name;\n  if (obj.keywords) obj.kt = obj.keywords;\n  if (obj.announce) obj.tr = obj.announce;\n\n  if (obj.urlList) {\n    obj.ws = obj.urlList;\n    delete obj.as;\n  }\n\n  let result = 'magnet:?';\n  Object.keys(obj).filter(key => key.length === 2).forEach((key, i) => {\n    const values = Array.isArray(obj[key]) ? obj[key] : [obj[key]];\n    values.forEach((val, j) => {\n      if ((i > 0 || j > 0) && (key !== 'kt' || j === 0)) result += '&';\n      if (key === 'dn') val = encodeURIComponent(val).replace(/%20/g, '+');\n\n      if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {\n        val = encodeURIComponent(val);\n      }\n\n      if (key === 'kt') val = encodeURIComponent(val);\n      if (key === 'kt' && j > 0) result += `+${val}`;else result += `${key}=${val}`;\n    });\n  });\n  return result;\n}","map":{"version":3,"sources":["/Users/tinvotan/Projects/fayrtv/fayr_test/fayrtv_test_2/node_modules/magnet-uri/index.js"],"names":["module","exports","magnetURIDecode","decode","encode","magnetURIEncode","base32","require","uniq","uri","result","data","split","params","length","forEach","param","keyval","key","val","decodeURIComponent","replace","Number","Array","isArray","push","old","m","xt","xts","match","infoHash","toLowerCase","decodedStr","Buffer","from","toString","infoHashBuffer","dn","name","kt","keywords","tr","announce","urlList","as","concat","ws","obj","Object","assign","keys","filter","i","values","j","encodeURIComponent"],"mappings":"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","sourcesContent":["module.exports = magnetURIDecode\nmodule.exports.decode = magnetURIDecode\nmodule.exports.encode = magnetURIEncode\n\nconst base32 = require('thirty-two')\nconst uniq = require('uniq')\n\n/**\n * Parse a magnet URI and return an object of keys/values\n *\n * @param  {string} uri\n * @return {Object} parsed uri\n */\nfunction magnetURIDecode (uri) {\n  const result = {}\n\n  // Support 'magnet:' and 'stream-magnet:' uris\n  const data = uri.split('magnet:?')[1]\n\n  const params = (data && data.length >= 0)\n    ? data.split('&')\n    : []\n\n  params.forEach(param => {\n    const keyval = param.split('=')\n\n    // This keyval is invalid, skip it\n    if (keyval.length !== 2) return\n\n    const key = keyval[0]\n    let val = keyval[1]\n\n    // Clean up torrent name\n    if (key === 'dn') val = decodeURIComponent(val).replace(/\\+/g, ' ')\n\n    // Address tracker (tr), exact source (xs), and acceptable source (as) are encoded\n    // URIs, so decode them\n    if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {\n      val = decodeURIComponent(val)\n    }\n\n    // Return keywords as an array\n    if (key === 'kt') val = decodeURIComponent(val).split('+')\n\n    // Cast file index (ix) to a number\n    if (key === 'ix') val = Number(val)\n\n    // If there are repeated parameters, return an array of values\n    if (result[key]) {\n      if (Array.isArray(result[key])) {\n        result[key].push(val)\n      } else {\n        const old = result[key]\n        result[key] = [old, val]\n      }\n    } else {\n      result[key] = val\n    }\n  })\n\n  // Convenience properties for parity with `parse-torrent-file` module\n  let m\n  if (result.xt) {\n    const xts = Array.isArray(result.xt) ? result.xt : [ result.xt ]\n    xts.forEach(xt => {\n      if ((m = xt.match(/^urn:btih:(.{40})/))) {\n        result.infoHash = m[1].toLowerCase()\n      } else if ((m = xt.match(/^urn:btih:(.{32})/))) {\n        const decodedStr = base32.decode(m[1])\n        result.infoHash = Buffer.from(decodedStr, 'binary').toString('hex')\n      }\n    })\n  }\n  if (result.infoHash) result.infoHashBuffer = Buffer.from(result.infoHash, 'hex')\n\n  if (result.dn) result.name = result.dn\n  if (result.kt) result.keywords = result.kt\n\n  if (typeof result.tr === 'string') result.announce = [ result.tr ]\n  else if (Array.isArray(result.tr)) result.announce = result.tr\n  else result.announce = []\n\n  result.urlList = []\n  if (typeof result.as === 'string' || Array.isArray(result.as)) {\n    result.urlList = result.urlList.concat(result.as)\n  }\n  if (typeof result.ws === 'string' || Array.isArray(result.ws)) {\n    result.urlList = result.urlList.concat(result.ws)\n  }\n\n  uniq(result.announce)\n  uniq(result.urlList)\n\n  return result\n}\n\nfunction magnetURIEncode (obj) {\n  obj = Object.assign({}, obj) // clone obj, so we can mutate it\n\n  // support using convenience names, in addition to spec names\n  // (example: `infoHash` for `xt`, `name` for `dn`)\n  if (obj.infoHashBuffer) obj.xt = `urn:btih:${obj.infoHashBuffer.toString('hex')}`\n  if (obj.infoHash) obj.xt = `urn:btih:${obj.infoHash}`\n  if (obj.name) obj.dn = obj.name\n  if (obj.keywords) obj.kt = obj.keywords\n  if (obj.announce) obj.tr = obj.announce\n  if (obj.urlList) {\n    obj.ws = obj.urlList\n    delete obj.as\n  }\n\n  let result = 'magnet:?'\n  Object.keys(obj)\n    .filter(key => key.length === 2)\n    .forEach((key, i) => {\n      const values = Array.isArray(obj[key]) ? obj[key] : [ obj[key] ]\n      values.forEach((val, j) => {\n        if ((i > 0 || j > 0) && (key !== 'kt' || j === 0)) result += '&'\n\n        if (key === 'dn') val = encodeURIComponent(val).replace(/%20/g, '+')\n        if (key === 'tr' || key === 'xs' || key === 'as' || key === 'ws') {\n          val = encodeURIComponent(val)\n        }\n        if (key === 'kt') val = encodeURIComponent(val)\n\n        if (key === 'kt' && j > 0) result += `+${val}`\n        else result += `${key}=${val}`\n      })\n    })\n\n  return result\n}\n"]},"metadata":{},"sourceType":"script"}